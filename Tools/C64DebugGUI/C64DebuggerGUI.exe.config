<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <configSections>
    <sectionGroup name="userSettings" type="System.Configuration.UserSettingsGroup, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
      <section name="C64DebuggerGUI.My.MySettings" type="System.Configuration.ClientSettingsSection, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" allowExeDefinition="MachineToLocalUser" requirePermission="false" />
      <section name="C64DebugGUI.My.MySettings" type="System.Configuration.ClientSettingsSection, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" allowExeDefinition="MachineToLocalUser" requirePermission="false" />
    </sectionGroup>
    <sectionGroup name="applicationSettings" type="System.Configuration.ApplicationSettingsGroup, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
      <section name="C64DebugGUI.My.MySettings" type="System.Configuration.ClientSettingsSection, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" requirePermission="false" />
    </sectionGroup>
  </configSections>
  <startup>
    <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5.2" />
  </startup>
  <runtime>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <probing privatePath="lib;libs" />
      <probing privatePath="lib;libs" xmlns="" />
    </assemblyBinding>
  </runtime>
  <userSettings>
    <C64DebuggerGUI.My.MySettings>
      <setting name="AutoloadAtClose" serializeAs="String">
        <value>False</value>
      </setting>
      <setting name="WinSize" serializeAs="String">
        <value>1000, 700</value>
      </setting>
      <setting name="WinPos" serializeAs="String">
        <value>10, 10</value>
      </setting>
      <setting name="ToolStripImgScalingSize" serializeAs="String">
        <value>20</value>
      </setting>
      <setting name="ToolStripBGColor" serializeAs="String">
        <value>LightGray</value>
      </setting>
      <setting name="ColTSPanelBG" serializeAs="String">
        <value>Control</value>
      </setting>
      <setting name="ColPanleBG" serializeAs="String">
        <value>Control</value>
      </setting>
      <setting name="ColMainTextFG" serializeAs="String">
        <value>ControlText</value>
      </setting>
      <setting name="ColMainBG" serializeAs="String">
        <value>Control</value>
      </setting>
      <setting name="ColTSHighlight" serializeAs="String">
        <value>GradientActiveCaption</value>
      </setting>
      <setting name="KillCBMDebugInstancesStartup" serializeAs="String">
        <value>True</value>
      </setting>
      <setting name="LogLevel" serializeAs="String">
        <value>1</value>
      </setting>
      <setting name="ColVHDTextBoxBG" serializeAs="String">
        <value>ControlLight</value>
      </setting>
      <setting name="ColVHDTextBoxFG" serializeAs="String">
        <value>ControlText</value>
      </setting>
      <setting name="ColButtonBG" serializeAs="String">
        <value>Control</value>
      </setting>
      <setting name="FontTextBox" serializeAs="String">
        <value>Courier New, 9.75pt</value>
      </setting>
      <setting name="ColNotesTextBoxBG" serializeAs="String">
        <value>Control</value>
      </setting>
      <setting name="ColNotesTextBoxFG" serializeAs="String">
        <value>ControlText</value>
      </setting>
      <setting name="Notes" serializeAs="String">
        <value />
      </setting>
      <setting name="ColNotesHighlight" serializeAs="String">
        <value>Yellow</value>
      </setting>
      <setting name="ColNotesHighlightFG" serializeAs="String">
        <value>1, 1, 1</value>
      </setting>
      <setting name="FileCalculator" serializeAs="String">
        <value>C:\Windows\System32\calc.exe</value>
      </setting>
      <setting name="SuppressC64dAtStartup" serializeAs="String">
        <value>False</value>
      </setting>
      <setting name="VHDAssembly" serializeAs="String">
        <value>Disassembly view:

Mouse Click on memory address
Add/remove breakpoint

` (~ tilde key)
Add/remove breakpoint

Arrow Up/Down
Scroll code one instruction up/down

Page Up/Page Down or Shift+Arrow Up/Shift+Arrow Down
Scroll code by $100 bytes up/down

Space
Toggle tracking of code display by current PC

Enter
Enter code editing mode (assemble)
	
[ or ]
Scroll code one byte up/down
	
Arrow Left/Right
If not editing code: follow code jumps and branches using
Right-Arrow key, and move back with Left-Arrow key. When 
argument is a memory address then Memory Dump view will be 
scrolled to that address.If editing code and hex values
visible: change edited hex value	
	
CTRL+G &lt;addr&gt;  
Move cursor to specific address (f.e. CTRL+G EA31)
		
CTRL+J
JMP to current cursor's address (change CPU PC)</value>
      </setting>
      <setting name="VHDVicDisplay" serializeAs="String">
        <value>VIC Display screen:

The VIC Display screen is like an X-Ray for the VIC chip. Whole frame is recorded
and you can access state of VIC and CPU for each cycle of the frame. It can 
be activated by Ctrl+Shift+F5. VIC Display renders exact state of VIC for 
selected cycle. As you know, a lot of effects are using tricks of the VIC chip, 
so it will not show the C64 screen in its entirety, as it is not meant to. 
It will always show a screen how it would be rendered for selected cycle of 
the VIC chip.

You can just move mouse cursor over the VIC Display frame and see how VIC
registers impact rendering of the C64 screen. Note that status of CPU registers
and VIC state view is marked in light-red color background, this is to indicate
that state is locked and shows selected raster cycle. The disassembly code is moved to 
the place where raster beam was executing code in the frame. Space bar changes 
disassembly code lock. Also, when you move the cursor over VIC Display, the memory dump
view cursor points to address which is under mouse cursor.

When you click on the VIC Display you can lock cursor and then move it with keyboard 
arrow keys, holding Shift will increase the step. You can unlock the cursor by pressing
Space Bar or by Mouse-Clicking on locked cursor.

There are buttons to control the VIC Display, you can see what are current values 
of VIC bank, screen, bitmap etc. and you can force and change them by clicking on 
values: green color means it is a current state for selected cycle, red is when you 
forced the selection. Do not forget, that if you select something making it red, then 
the VIC Display will show your selection, not what is currently going on on the screen.

Button "Scroll" will switch if VIC scroll register should be applied to VIC Display 
position. When code is opening side borders then applying the scroll register may make
the display jump a lot, so you can select if you need this behaviour.

Button "Bad Line" shows a bad line condition when text is red, switching it on will 
display lines that are in bad line condition.  

Button "Border" changes if side border should be shown. It has three states: no border,
viewable area with border, full frame scan.

Button "Grid" changes if a grid should be displayed.

Button "Sprites" changes if sprites graphics should be rendered in the VIC Display.

Button "Frames" changes if frames around sprites should be visible.

Button "Break" adds VIC raster breakpoint, the text is in red when a selected line has 
already the breakpoint set.

The "Show PC for" informs in which auto-scroll code disassembly mode we are, you can 
click on the mode and change it to other mode (Raster / Screen / Bitmap / Colour).

VIC Display records state of VIC each cycle in the frame and with the mouse cursor you
can see what is in the frame. The X key changes what we "look" at: where was the code 
in a given cycle (Raster mode) or where the code saved the pixel in memory (Raster / 
Screen / Bitmap / Colour). For Screen / Bitmap / Colour modes the memory
view under C64 screen will be moved to address that holds the value at cursor.

You can Right-Click on C64 Screen in right top to replace it to a zoomed raster view. 

Keys that you can use in this view are:

Arrow keys
	Move locked cursor
	
Shift+Arrow keys
Move locked cursor in large steps
	
` (~ tilde key)
Toggle VIC raster breakpoint
	
L
Lock/Unlock mouse cursor
	
Space Bar
Lock/Unlock Disassemble auto-scroll code
	
X
Select next auto-scroll code mode
	
R
Select auto-scroll code to Raster
	
S
Select auto-scroll code to Screen (Text)
	
B
Select auto-scroll code to Bitmap
	
C
Select auto-scroll code to Colour</value>
      </setting>
      <setting name="VHDVicEditor" serializeAs="String">
        <value>VIC Editor screen:

The VIC Editor screen is for displaying and editing graphics in real time. All painting
is done in a live C64 emulation and is immediately reflected in C64 RAM and VIC chip.

Layers window shows available layers, default layers are:
- Unrestricted: you can paint on this layer in so-called hires unrestricted mode, thus 
  using C64 colors without any limits
- Sprites: this layer is used for painting on all visible sprites in this frame. These 
  are virtual sprites, so in particular de-multiplexed sprites. Note, that displaying 
  of virtual sprites from this layer is not implemented yet, thus the "V" button changes 
  only if you can paint on this layer. However, you can see these sprites as they are 
  rendered in the C64 Screen, so actually you can paint on them and see changes.
- C64 Sprites: these are sprites that are in a raster line under cursor, just the same
  like in VIC Display view.
- Display: this is the same VIC Display which works exactly the same way, thus exact 
  state of VIC for selected cycle under cursor is rendered.
- C64 Screen: this is the C64 Screen as it was rendered by VIC, note that if emulation 
  is paused, then painting on this layer will not have immediate affect - the VIC must 
  render the screen first to have changes visible.
	
There are “V” buttons near layers names, these set visibility of the layer. 

You can select the layer by clicking on it:
When layer is selected, all painting is done on that selected layer, even if it is 
not visible. 
When no layer is selected, then painting is made from top-to-bottom, it is driven to 
a layer that has higher priority first, that is visible and has a pixel under 
selected x/y mouse position which is inside that layer (for example if there are no 
sprites under mouse cursor, then sprites layer will be skipped and painting will be 
done on C64 bitmap).

Painting depends on selected mode. In all modes you are free to paint, however if you 
exceed available number of colors the painting will be blocked. To un-block and force
color replace you can hold Ctrl key  (this can be configured in Settings). 

The replacement color will be selected and it will be replaced: 
- in Hires Bitmap this will be color under cursor in 8x8 char,
- in Multi-Color Bitmap this will be color that is less-used in 8x8 char (has least 
  number of pixels),
- on Sprite this will always be individual sprite color ($D027+).

Painting with RMB On Sprite will always use background color ($D021).

You can paint in dither mode by holding Alt key: pixel colors are alternating between 
LMB and RMB. When you paint first pixel, a dithering grid will be created, and by 
holding Alt key this grid will be used for painting. The dithering grid will be reset 
when you release the Alt key.

Sprite window shows current selected sprite. You can lock selected sprite by clicking 
mouse on sprite with Ctrl+Shift. Then you can select color to use for paiting by clicking 
on the color in Sprite window or by pressing (0, Shift+1, Shift+2, Shift+3). 
To change locked color just select a new color from palette, this will replace 
the color of locked Sprite. Note that $D021, $D025 and $D026 are shared with other 
sprites. If you not select color in Sprite window, then painting on Sprite will try 
to use selected color from the Palette, if color is not in available colors then the
painting will be blocked and to un-block and force color replace use the Ctrl key.

You can change multicolor, horizontal or vertical stretch by clicking buttons.

You can change positions of Sprites the same way, just lock/select a Sprite
by pressing Ctrl+Shift+Mouse Click on that sprite, and then use Arrow Keys
to move that selected sprite (Arrow Key Left/Right/Up/Down).

Note, that changing colors, positions and settings of Sprites is quasi-intelligent: 
in current frame's code that was run, places of LDA/LDX/LDY and STA/STX/STY pairs 
are found for sprite colors or positions and values of LDA's are replaced based on 
current raster position. Thus, you can write your own display and colors multiplexer 
code, run it and when you change colors of sprites the code in C64 RAM will be replaced 
accordingly, even if you use Sprite multiplexing.

Charset window shows current charset, you can select char and use it for painting in
text modes.

It is possible to import PNG and convert it to current mode, hires/multicolor bitmap
and hires text modes are supported. PNG must have resolution of 320x200 or 384x272. 
Colors are matched to nearest C64 colors (nearest neighbour). For bitmap modes colors
in 8x8 are set based on most used color values in 8x8, thus first a color that has
largest number of occurrences in 8x8 char is found and it is replaced for converting
in that 8x8 char, then in multicolor the another one, etc. If sprites are present in 
the screen, colors are matched to colors selected in the sprite and pixels are converted, 
note that no automatic color replacing is possible at this moment. The 384x272 resolution 
includes also borders, so if you have sprites in side border the pixels will be 
converted accordingly.

Note, that a workflow with sprites is that you should have some init PRG procedure that
sets position of sprites. The converter is quasi-intelligent, thus is trying to find
places of LDA/STA for colors in the current frame. 

You can also import KLA (Bitmap Multi-Color), ART (Bitmap Hires), DD (Bitmap Hires) and
export to KLA, ART or raw text depending on selected mode.

Zooming and panning of the canvas is performed using mouse, you can use Mouse Scroll
for zooming and hold Space Bar for panning. Also, you can Mouse Right-Click on Preview
Window to quickly move the painting area to selected position. When you zoom-in deeply
then numbers such as pixel addresses and values will be also shown.


VIC Editor keys: (LMB=left mouse button, RMB=right mouse button)

LMB, RMB
Paint using selected color
	
Alt+LMB, Alt+RMB
Paint dither
	
Ctrl+LMB or Ctrl+RMB 
Force painting / replace color
	
Shift+LMB
Get color at cursor as LMB color
	
Shift+LMB
Get color at cursor as RMB color
	
X
Exchange LMB/RMB colors
	
0
Set LMB color from $D021 color
	
Shift+0
Get color at cursor as background ($D021) color
	
RMB on Preview Window
Move display
	
Space Bar (hold in main display)
Move display
	
Mouse Scroll
Zoom in/out the canvas
	
Shift+Mouse Scroll
Quickly zoom in/out the canvas
	
[ or ]
Select Circle Brush size
	
Ctrl+[ or Ctrl+] 
Select Rectangle Brush size
	
/
Change Preview Window scale
	
'
Show cursor pointer in Preview Window
	
` (tilde key)
Select next visible layer
	
12345678QWERTYUI
Select color
	
Shift+1, Shift+2, Shift+3
Select sprite painting color num ($D025, $D027+, $D026)

F
Show/hide all windows
	
D
Show/hide preview window
	
P
Show/hide colors palette
	
C
Show/hide character set window
	
S
Show/hide sprite window
	
L
Show/hide layers window
	
Ctrl+G
Show/hide sprite frames
	
Ctrl+Shift+Mouse Click
Lock/Select sprite
	
Arrow Left/Right/Up/Down
Move selected sprite
	
Ctrl+Backspace
Clear screen
	
Ctrl+Z
Undo
	
Ctrl+Shift+Z
Redo
	
Ctrl+S
Save image in VIC Editor (*.vce) format
	
Ctrl+O
Load/Import image (vce, png, kla, art, dd)
	
Ctrl+Shift+E
Export image to kla/art/raw text
	
ESCAPE
Back to C64 Debugger</value>
      </setting>
      <setting name="VHDMonitor" serializeAs="String">
        <value>Monitor screen:

You can use these instructions in code monitor:

HELP
shows help
	
DEVICE C / D / 8
set current device (C64/Disk/Disk)
	
F &lt;from address&gt; &lt;to address&gt; &lt;value&gt;
fill memory with value
	
C &lt;from address&gt; &lt;to address&gt; &lt;destination address&gt;
compare memory with memory
	
H &lt;from address&gt; &lt;to address&gt; &lt;value&gt; [&lt;value&gt; ...]
compare memory with values
	
T &lt;from address&gt; &lt;to address&gt; &lt;destination address&gt;
copy memory
	
L [PRG] [from address] [file name]
load memory (with option from PRG file)
	
S [PRG] &lt;from address&gt; &lt;to address&gt; [file name]
save memory (with option as PRG file)
	
D [NH] &lt;from address&gt; &lt;to address&gt; [file name]
disassemble memory (with option NH without hex codes)
	
G &lt;address&gt;
jmp to address</value>
      </setting>
      <setting name="AdditionalClArgs" serializeAs="String">
        <value />
      </setting>
      <setting name="FTPuseAltDomain" serializeAs="String">
        <value>False</value>
      </setting>
      <setting name="FTPAltDomain" serializeAs="String">
        <value>192.168.1.50</value>
      </setting>
      <setting name="CheckUpdatesAtStart" serializeAs="String">
        <value>False</value>
      </setting>
      <setting name="MuteOnPause" serializeAs="String">
        <value>True</value>
      </setting>
      <setting name="AutoTidyToolstrips" serializeAs="String">
        <value>True</value>
      </setting>
      <setting name="SettsPos" serializeAs="String">
        <value>100, 100</value>
      </setting>
      <setting name="SettsSize" serializeAs="String">
        <value>661, 482</value>
      </setting>
      <setting name="KeyDownWait" serializeAs="String">
        <value>25</value>
      </setting>
      <setting name="SetParentWait" serializeAs="String">
        <value>200</value>
      </setting>
      <setting name="ShowWindowWait" serializeAs="String">
        <value>300</value>
      </setting>
      <setting name="VHDData" serializeAs="String">
        <value>Data dump view:

Mouse Click on hex value
Select hex value
	
Double Mouse Click on hex value
Scroll disassemble view to selected address
	
Arrow keys
Move editing cursor
	
Page Up/Page Down or Shift+Arrow Up/Shift+Arrow Down
Scroll code by $100 bytes up/down
	
Enter or 0-9 or A-F
Start editing value
	
Ctrl+Mouse Click
Scroll Disassembly to code address that stored that value
	
Alt+Shift
Change CBM charset	
	
Ctrl+K
Change colour mode on/off for sprites/characters
	
Ctrl+G &lt;addr&gt;
Move cursor to specific address (f.e. CTRL+G 0400)
	
Ctrl+V
Paste hex codes from clipboard into memory. Simple separators are
parsed, also the text can contain addresses as 4 hex digits</value>
      </setting>
      <setting name="VHDMemory" serializeAs="String">
        <value>Memory map view:

Memory map shows current values of memory cells. Ctrl+M switches bank to
RAM. Each memory cell value is mapped into RGB or Gray or None. In RGB mode 
red are values from 0 to 85, green are values from 85 to 170 and blue are 
values from 170 to 255. In Gray mode all values are mapped into grayscale
colors.

Memory access:
  white shows current PC
  blue  marks read access
  red   marks write access

You can change colours to ICU-standard (read marked by green) in Settings.

You can Mouse Click inside memory map to scroll data dump view to a clicked 
memory address. You can double Mouse Click to scroll disassemble view to a 
memory address under cursor. You can Ctrl+Mouse Click to scroll Disassembly 
to code address that stored value under cursor.

You can zoom-in using mouse wheel and move around by holding right mouse click
(Windows, Linux, MacOS) or use mulitouch gestures such as pinch zoom and 
scroll using two fingers (MacOS only). You can select desired control behaviour 
in Settings.</value>
      </setting>
      <setting name="VHDBreakpoints" serializeAs="String">
        <value>Breakpoints screen:

Breakpoint stops the execution of code depending on some state and situation.
In the Breakpoints screen (Ctrl + B) you can click using mouse, or Enter or
Space key to enable or disable monitoring of selected type of the breakpoint.
New value can be added by selecting "...." either by moving the cursor with the 
arrow keys or clicking using mouse. 

These are possibilities:

VIC / CIA / NMI - stops when selected interruption occurs

CPU PC - the code will stop as the processor will start to perform instruction 
from selected address
	   
MEMORY - stops when there will be attempt to write to the memory of the set 
value, for example: 4FFF &lt;= 3F will stop code when there will be 
attempt to write to the cells 4FFF value less or equal to 3F. To
break at any write access you can use &lt;= FF
	   
RASTER - stops when raster reaches the set line value

Breakpoints CPU type PC can also be set in the disassembler view by clicking
the mouse cursor on the address or by pressing the ` (tilde) key.

The same applies to 1541 Drive breakpoints on right side of the screen.

Arrow keys
Move around
	
Enter or Spacebar
Toggle value or start editing breakpoint


* Commodore 64 screen

All keys are mapped as original Commodore 64 keyboard. RUN+STOP is mapped to
ESC key. Left Control key is not mapped and reserved for keyboard shortcuts. 
Right Control is mapped into C64 Control key. RESTORE is not mapped, but you can change 
this in Settings. 

When joystick is turned on then you can control selected ports using arrow keys,
and right-alt as fire.</value>
      </setting>
      <setting name="VHDChips" serializeAs="String">
        <value>Chips View:

SID state view

You can click waveforms to mute SID channels. Detected musical notes are
displayed, these are based on standard 440Hz A4 notation.

VIC state view

This view shows state of VIC registers. You can lock colors using Mouse Left Click,
or change them using Mouse Right Click, these will be reflected in previews like
Memory Dump or VIC Display view.</value>
      </setting>
      <setting name="MainSCSplitterDistPerc" serializeAs="String">
        <value>25</value>
      </setting>
      <setting name="DocsSplitter" serializeAs="String">
        <value>254</value>
      </setting>
      <setting name="colStatusBarText" serializeAs="String">
        <value>Gray</value>
      </setting>
    </C64DebuggerGUI.My.MySettings>
    <C64DebugGUI.My.MySettings>
      <setting name="AutoloadAtClose" serializeAs="String">
        <value>False</value>
      </setting>
      <setting name="WinSize" serializeAs="String">
        <value>1000, 700</value>
      </setting>
      <setting name="WinPos" serializeAs="String">
        <value>10, 10</value>
      </setting>
      <setting name="ToolStripImgScalingSize" serializeAs="String">
        <value>20</value>
      </setting>
      <setting name="ToolStripBGColor" serializeAs="String">
        <value>LightGray</value>
      </setting>
      <setting name="ColTSPanelBG" serializeAs="String">
        <value>Control</value>
      </setting>
      <setting name="ColPanleBG" serializeAs="String">
        <value>Control</value>
      </setting>
      <setting name="ColMainTextFG" serializeAs="String">
        <value>ControlText</value>
      </setting>
      <setting name="ColMainBG" serializeAs="String">
        <value>Control</value>
      </setting>
      <setting name="ColTSHighlight" serializeAs="String">
        <value>GradientActiveCaption</value>
      </setting>
      <setting name="KillCBMDebugInstancesStartup" serializeAs="String">
        <value>True</value>
      </setting>
      <setting name="LogLevel" serializeAs="String">
        <value>1</value>
      </setting>
      <setting name="VHDData" serializeAs="String">
        <value>Data dump view:

Mouse Click on hex value
Select hex value
	
Double Mouse Click on hex value
Scroll disassemble view to selected address
	
Arrow keys
Move editing cursor
	
Page Up/Page Down or Shift+Arrow Up/Shift+Arrow Down
Scroll code by $100 bytes up/down
	
Enter or 0-9 or A-F
Start editing value
	
Ctrl+Mouse Click
Scroll Disassembly to code address that stored that value
	
Alt+Shift
Change CBM charset	
	
Ctrl+K
Change colour mode on/off for sprites/characters
	
Ctrl+G &lt;addr&gt;
Move cursor to specific address (f.e. CTRL+G 0400)
	
Ctrl+V
Paste hex codes from clipboard into memory. Simple separators are
parsed, also the text can contain addresses as 4 hex digits</value>
      </setting>
      <setting name="VHDMemory" serializeAs="String">
        <value>Memory map view:

Memory map shows current values of memory cells. Ctrl+M switches bank to
RAM. Each memory cell value is mapped into RGB or Gray or None. In RGB mode 
red are values from 0 to 85, green are values from 85 to 170 and blue are 
values from 170 to 255. In Gray mode all values are mapped into grayscale
colors.

Memory access:
  white shows current PC
  blue  marks read access
  red   marks write access

You can change colours to ICU-standard (read marked by green) in Settings.

You can Mouse Click inside memory map to scroll data dump view to a clicked 
memory address. You can double Mouse Click to scroll disassemble view to a 
memory address under cursor. You can Ctrl+Mouse Click to scroll Disassembly 
to code address that stored value under cursor.

You can zoom-in using mouse wheel and move around by holding right mouse click
(Windows, Linux, MacOS) or use mulitouch gestures such as pinch zoom and 
scroll using two fingers (MacOS only). You can select desired control behaviour 
in Settings.</value>
      </setting>
      <setting name="VHDBreakpoints" serializeAs="String">
        <value>Breakpoints screen:

Breakpoint stops the execution of code depending on some state and situation.
In the Breakpoints screen (Ctrl + B) you can click using mouse, or Enter or
Space key to enable or disable monitoring of selected type of the breakpoint.
New value can be added by selecting "...." either by moving the cursor with the 
arrow keys or clicking using mouse. 

These are possibilities:

VIC / CIA / NMI - stops when selected interruption occurs

CPU PC - the code will stop as the processor will start to perform instruction 
from selected address
	   
MEMORY - stops when there will be attempt to write to the memory of the set 
value, for example: 4FFF &lt;= 3F will stop code when there will be 
attempt to write to the cells 4FFF value less or equal to 3F. To
break at any write access you can use &lt;= FF
	   
RASTER - stops when raster reaches the set line value

Breakpoints CPU type PC can also be set in the disassembler view by clicking
the mouse cursor on the address or by pressing the ` (tilde) key.

The same applies to 1541 Drive breakpoints on right side of the screen.

Arrow keys
Move around
	
Enter or Spacebar
Toggle value or start editing breakpoint


* Commodore 64 screen

All keys are mapped as original Commodore 64 keyboard. RUN+STOP is mapped to
ESC key. Left Control key is not mapped and reserved for keyboard shortcuts. 
Right Control is mapped into C64 Control key. RESTORE is not mapped, but you can change 
this in Settings. 

When joystick is turned on then you can control selected ports using arrow keys,
and right-alt as fire.</value>
      </setting>
      <setting name="VHDChips" serializeAs="String">
        <value>Chips View:

SID state view

You can click waveforms to mute SID channels. Detected musical notes are
displayed, these are based on standard 440Hz A4 notation.

VIC state view

This view shows state of VIC registers. You can lock colors using Mouse Left Click,
or change them using Mouse Right Click, these will be reflected in previews like
Memory Dump or VIC Display view.</value>
      </setting>
      <setting name="ColVHDTextBoxBG" serializeAs="String">
        <value>ControlLight</value>
      </setting>
      <setting name="ColVHDTextBoxFG" serializeAs="String">
        <value>ControlText</value>
      </setting>
      <setting name="ColButtonBG" serializeAs="String">
        <value>Control</value>
      </setting>
      <setting name="FontTextBox" serializeAs="String">
        <value>Courier New, 9.75pt</value>
      </setting>
      <setting name="ColNotesTextBoxBG" serializeAs="String">
        <value>Control</value>
      </setting>
      <setting name="ColNotesTextBoxFG" serializeAs="String">
        <value>ControlText</value>
      </setting>
      <setting name="Notes" serializeAs="String">
        <value />
      </setting>
      <setting name="ColNotesHighlight" serializeAs="String">
        <value>Yellow</value>
      </setting>
      <setting name="ColNotesHighlightFG" serializeAs="String">
        <value>ControlText</value>
      </setting>
      <setting name="FileCalculator" serializeAs="String">
        <value>C:\Windows\System32\calc.exe</value>
      </setting>
      <setting name="SuppressC64dAtStartup" serializeAs="String">
        <value>False</value>
      </setting>
      <setting name="VHDAssembly" serializeAs="String">
        <value>Disassembly view:

Mouse Click on memory address
Add/remove breakpoint

` (~ tilde key)
Add/remove breakpoint

Arrow Up/Down
Scroll code one instruction up/down

Page Up/Page Down or Shift+Arrow Up/Shift+Arrow Down
Scroll code by $100 bytes up/down

Space
Toggle tracking of code display by current PC

Enter
Enter code editing mode (assemble)
	
[ or ]
Scroll code one byte up/down
	
Arrow Left/Right
If not editing code: follow code jumps and branches using
Right-Arrow key, and move back with Left-Arrow key. When 
argument is a memory address then Memory Dump view will be 
scrolled to that address.If editing code and hex values
visible: change edited hex value	
	
CTRL+G &lt;addr&gt;  
Move cursor to specific address (f.e. CTRL+G EA31)
		
CTRL+J
JMP to current cursor's address (change CPU PC)</value>
      </setting>
      <setting name="VHDVicDisplay" serializeAs="String">
        <value>VIC Display screen:

The VIC Display screen is like an X-Ray for the VIC chip. Whole frame is recorded
and you can access state of VIC and CPU for each cycle of the frame. It can 
be activated by Ctrl+Shift+F5. VIC Display renders exact state of VIC for 
selected cycle. As you know, a lot of effects are using tricks of the VIC chip, 
so it will not show the C64 screen in its entirety, as it is not meant to. 
It will always show a screen how it would be rendered for selected cycle of 
the VIC chip.

You can just move mouse cursor over the VIC Display frame and see how VIC
registers impact rendering of the C64 screen. Note that status of CPU registers
and VIC state view is marked in light-red color background, this is to indicate
that state is locked and shows selected raster cycle. The disassembly code is moved to 
the place where raster beam was executing code in the frame. Space bar changes 
disassembly code lock. Also, when you move the cursor over VIC Display, the memory dump
view cursor points to address which is under mouse cursor.

When you click on the VIC Display you can lock cursor and then move it with keyboard 
arrow keys, holding Shift will increase the step. You can unlock the cursor by pressing
Space Bar or by Mouse-Clicking on locked cursor.

There are buttons to control the VIC Display, you can see what are current values 
of VIC bank, screen, bitmap etc. and you can force and change them by clicking on 
values: green color means it is a current state for selected cycle, red is when you 
forced the selection. Do not forget, that if you select something making it red, then 
the VIC Display will show your selection, not what is currently going on on the screen.

Button "Scroll" will switch if VIC scroll register should be applied to VIC Display 
position. When code is opening side borders then applying the scroll register may make
the display jump a lot, so you can select if you need this behaviour.

Button "Bad Line" shows a bad line condition when text is red, switching it on will 
display lines that are in bad line condition.  

Button "Border" changes if side border should be shown. It has three states: no border,
viewable area with border, full frame scan.

Button "Grid" changes if a grid should be displayed.

Button "Sprites" changes if sprites graphics should be rendered in the VIC Display.

Button "Frames" changes if frames around sprites should be visible.

Button "Break" adds VIC raster breakpoint, the text is in red when a selected line has 
already the breakpoint set.

The "Show PC for" informs in which auto-scroll code disassembly mode we are, you can 
click on the mode and change it to other mode (Raster / Screen / Bitmap / Colour).

VIC Display records state of VIC each cycle in the frame and with the mouse cursor you
can see what is in the frame. The X key changes what we "look" at: where was the code 
in a given cycle (Raster mode) or where the code saved the pixel in memory (Raster / 
Screen / Bitmap / Colour). For Screen / Bitmap / Colour modes the memory
view under C64 screen will be moved to address that holds the value at cursor.

You can Right-Click on C64 Screen in right top to replace it to a zoomed raster view. 

Keys that you can use in this view are:

Arrow keys
	Move locked cursor
	
Shift+Arrow keys
Move locked cursor in large steps
	
` (~ tilde key)
Toggle VIC raster breakpoint
	
L
Lock/Unlock mouse cursor
	
Space Bar
Lock/Unlock Disassemble auto-scroll code
	
X
Select next auto-scroll code mode
	
R
Select auto-scroll code to Raster
	
S
Select auto-scroll code to Screen (Text)
	
B
Select auto-scroll code to Bitmap
	
C
Select auto-scroll code to Colour</value>
      </setting>
      <setting name="VHDVicEditor" serializeAs="String">
        <value>VIC Editor screen:

The VIC Editor screen is for displaying and editing graphics in real time. All painting
is done in a live C64 emulation and is immediately reflected in C64 RAM and VIC chip.

Layers window shows available layers, default layers are:
- Unrestricted: you can paint on this layer in so-called hires unrestricted mode, thus 
  using C64 colors without any limits
- Sprites: this layer is used for painting on all visible sprites in this frame. These 
  are virtual sprites, so in particular de-multiplexed sprites. Note, that displaying 
  of virtual sprites from this layer is not implemented yet, thus the "V" button changes 
  only if you can paint on this layer. However, you can see these sprites as they are 
  rendered in the C64 Screen, so actually you can paint on them and see changes.
- C64 Sprites: these are sprites that are in a raster line under cursor, just the same
  like in VIC Display view.
- Display: this is the same VIC Display which works exactly the same way, thus exact 
  state of VIC for selected cycle under cursor is rendered.
- C64 Screen: this is the C64 Screen as it was rendered by VIC, note that if emulation 
  is paused, then painting on this layer will not have immediate affect - the VIC must 
  render the screen first to have changes visible.
	
There are “V” buttons near layers names, these set visibility of the layer. 

You can select the layer by clicking on it:
When layer is selected, all painting is done on that selected layer, even if it is 
not visible. 
When no layer is selected, then painting is made from top-to-bottom, it is driven to 
a layer that has higher priority first, that is visible and has a pixel under 
selected x/y mouse position which is inside that layer (for example if there are no 
sprites under mouse cursor, then sprites layer will be skipped and painting will be 
done on C64 bitmap).

Painting depends on selected mode. In all modes you are free to paint, however if you 
exceed available number of colors the painting will be blocked. To un-block and force
color replace you can hold Ctrl key  (this can be configured in Settings). 

The replacement color will be selected and it will be replaced: 
- in Hires Bitmap this will be color under cursor in 8x8 char,
- in Multi-Color Bitmap this will be color that is less-used in 8x8 char (has least 
  number of pixels),
- on Sprite this will always be individual sprite color ($D027+).

Painting with RMB On Sprite will always use background color ($D021).

You can paint in dither mode by holding Alt key: pixel colors are alternating between 
LMB and RMB. When you paint first pixel, a dithering grid will be created, and by 
holding Alt key this grid will be used for painting. The dithering grid will be reset 
when you release the Alt key.

Sprite window shows current selected sprite. You can lock selected sprite by clicking 
mouse on sprite with Ctrl+Shift. Then you can select color to use for paiting by clicking 
on the color in Sprite window or by pressing (0, Shift+1, Shift+2, Shift+3). 
To change locked color just select a new color from palette, this will replace 
the color of locked Sprite. Note that $D021, $D025 and $D026 are shared with other 
sprites. If you not select color in Sprite window, then painting on Sprite will try 
to use selected color from the Palette, if color is not in available colors then the
painting will be blocked and to un-block and force color replace use the Ctrl key.

You can change multicolor, horizontal or vertical stretch by clicking buttons.

You can change positions of Sprites the same way, just lock/select a Sprite
by pressing Ctrl+Shift+Mouse Click on that sprite, and then use Arrow Keys
to move that selected sprite (Arrow Key Left/Right/Up/Down).

Note, that changing colors, positions and settings of Sprites is quasi-intelligent: 
in current frame's code that was run, places of LDA/LDX/LDY and STA/STX/STY pairs 
are found for sprite colors or positions and values of LDA's are replaced based on 
current raster position. Thus, you can write your own display and colors multiplexer 
code, run it and when you change colors of sprites the code in C64 RAM will be replaced 
accordingly, even if you use Sprite multiplexing.

Charset window shows current charset, you can select char and use it for painting in
text modes.

It is possible to import PNG and convert it to current mode, hires/multicolor bitmap
and hires text modes are supported. PNG must have resolution of 320x200 or 384x272. 
Colors are matched to nearest C64 colors (nearest neighbour). For bitmap modes colors
in 8x8 are set based on most used color values in 8x8, thus first a color that has
largest number of occurrences in 8x8 char is found and it is replaced for converting
in that 8x8 char, then in multicolor the another one, etc. If sprites are present in 
the screen, colors are matched to colors selected in the sprite and pixels are converted, 
note that no automatic color replacing is possible at this moment. The 384x272 resolution 
includes also borders, so if you have sprites in side border the pixels will be 
converted accordingly.

Note, that a workflow with sprites is that you should have some init PRG procedure that
sets position of sprites. The converter is quasi-intelligent, thus is trying to find
places of LDA/STA for colors in the current frame. 

You can also import KLA (Bitmap Multi-Color), ART (Bitmap Hires), DD (Bitmap Hires) and
export to KLA, ART or raw text depending on selected mode.

Zooming and panning of the canvas is performed using mouse, you can use Mouse Scroll
for zooming and hold Space Bar for panning. Also, you can Mouse Right-Click on Preview
Window to quickly move the painting area to selected position. When you zoom-in deeply
then numbers such as pixel addresses and values will be also shown.


VIC Editor keys: (LMB=left mouse button, RMB=right mouse button)

LMB, RMB
Paint using selected color
	
Alt+LMB, Alt+RMB
Paint dither
	
Ctrl+LMB or Ctrl+RMB 
Force painting / replace color
	
Shift+LMB
Get color at cursor as LMB color
	
Shift+LMB
Get color at cursor as RMB color
	
X
Exchange LMB/RMB colors
	
0
Set LMB color from $D021 color
	
Shift+0
Get color at cursor as background ($D021) color
	
RMB on Preview Window
Move display
	
Space Bar (hold in main display)
Move display
	
Mouse Scroll
Zoom in/out the canvas
	
Shift+Mouse Scroll
Quickly zoom in/out the canvas
	
[ or ]
Select Circle Brush size
	
Ctrl+[ or Ctrl+] 
Select Rectangle Brush size
	
/
Change Preview Window scale
	
'
Show cursor pointer in Preview Window
	
` (tilde key)
Select next visible layer
	
12345678QWERTYUI
Select color
	
Shift+1, Shift+2, Shift+3
Select sprite painting color num ($D025, $D027+, $D026)

F
Show/hide all windows
	
D
Show/hide preview window
	
P
Show/hide colors palette
	
C
Show/hide character set window
	
S
Show/hide sprite window
	
L
Show/hide layers window
	
Ctrl+G
Show/hide sprite frames
	
Ctrl+Shift+Mouse Click
Lock/Select sprite
	
Arrow Left/Right/Up/Down
Move selected sprite
	
Ctrl+Backspace
Clear screen
	
Ctrl+Z
Undo
	
Ctrl+Shift+Z
Redo
	
Ctrl+S
Save image in VIC Editor (*.vce) format
	
Ctrl+O
Load/Import image (vce, png, kla, art, dd)
	
Ctrl+Shift+E
Export image to kla/art/raw text
	
ESCAPE
Back to C64 Debugger</value>
      </setting>
      <setting name="VHDMonitor" serializeAs="String">
        <value>Monitor screen:

You can use these instructions in code monitor:

HELP
shows help
	
DEVICE C / D / 8
set current device (C64/Disk/Disk)
	
F &lt;from address&gt; &lt;to address&gt; &lt;value&gt;
fill memory with value
	
C &lt;from address&gt; &lt;to address&gt; &lt;destination address&gt;
compare memory with memory
	
H &lt;from address&gt; &lt;to address&gt; &lt;value&gt; [&lt;value&gt; ...]
compare memory with values
	
T &lt;from address&gt; &lt;to address&gt; &lt;destination address&gt;
copy memory
	
L [PRG] [from address] [file name]
load memory (with option from PRG file)
	
S [PRG] &lt;from address&gt; &lt;to address&gt; [file name]
save memory (with option as PRG file)
	
D [NH] &lt;from address&gt; &lt;to address&gt; [file name]
disassemble memory (with option NH without hex codes)
	
G &lt;address&gt;
jmp to address</value>
      </setting>
      <setting name="AdditionalClArgs" serializeAs="String">
        <value />
      </setting>
      <setting name="FTPuseAltDomain" serializeAs="String">
        <value>False</value>
      </setting>
      <setting name="FTPAltDomain" serializeAs="String">
        <value>192.168.1.50</value>
      </setting>
      <setting name="CheckUpdatesAtStart" serializeAs="String">
        <value>True</value>
      </setting>
    </C64DebugGUI.My.MySettings>
  </userSettings>
  <applicationSettings>
    <C64DebugGUI.My.MySettings>
      <setting name="FileBrowseString" serializeAs="String">
        <value>...</value>
      </setting>
    </C64DebugGUI.My.MySettings>
  </applicationSettings>
</configuration>